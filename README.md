# Сервис прогнозирования риска инсульта

 В этом проекте мы в команде из трех человек (bobettov (Беккер Анита) - Backend-инженер (тимлид), njadabud (Толстых Александр) - ML-инженер, greedocl (Ремезова Арина) - Backend-инженер (интерфейсы и интеграция)) реализовали телеграмм чат-бота, который помогает прогнозировать риск инсульта и предлагает рекомендации по его снижению.

## Содержание

• Описание <br>
• Поиск данных,  анализ данных и создание модели машинного обучения <br>
• Реализация сбора данных в Telegram боте<br>
• Тестирование и подготовка документации<br>

## Описание 

Этот чат-бот предназначен для оценки риска инсульта на основе предоставленных пользователем данных и предоставления персонализированных рекомендаций по снижению этого риска. Он использует модель машинного обучения для прогнозирования и создает персонализированные рекомендации  по снижению этого риска на осонове искусственного интеллекта от Сбера (GigaChat).

### Поиск данных,  анализ данных и создание модели машинного обучения

Для разработки чат-бота мы использовали [датасет для прогнозирования инсульта](https://www.kaggle.com/datasets/fedesoriano/stroke-prediction-dataset), доступный на Kaggle. Этот набор данных содержит информацию о различных параметрах, которые могут влиять на риск инсульта, включая:

•   **Демографические данные:** Пол, возраст. <br>
•   **Состояние здоровья:** Наличие различных заболеваний (гипертония, сердечные заболевания). <br>
•   **Образ жизни:** Информация о семейном положении (состоял ли в браке), тип работы, тип места жительства. <br>
•   **Вредные привычки:** Статус курения. <br>
•   **Клинические показатели:** Средний уровень глюкозы в крови, индекс массы тела (BMI). <br>

**Разведочный анализ и предобработка данных:**

Перед обучением модели машинного обучения был проведен тщательный разведочный анализ данных (EDA) для понимания структуры и характеристик данных. Это включало:

•  Разделение признаков на дискретные и категориальные <br>
•  Обработка пропущенных значений <br>
•  Таргетная визуализация переменной (инсульт) <br>
•  Сравнение Категориальных признаков и Дискретныех признаков относительно Целевой переменной (инсульт) <br>
•  Балансировка данных с SMOTE <br>

**Выбор модели и обучение:**

Для прогнозирования риска инсульта были исследованы различные модели машинного обучения, включая:

•   Random Forest <br>
•   Gradient Boosting <br>
•   Logistic Regression <br>
•   XGBoost <br>

После тщательного сравнения моделей по нескольким метрикам, лучшей была признана модель **Gradient Boosting**, показавшая наилучшие результаты на тестовом наборе данных. 

**Метрики оценки модели:**

Производительность обученной модели оценивалась по следующим метрикам:

•   **ROC AUC (Area Under the Receiver Operating Characteristic Curve):** 0.82 - Показывает способность модели различать классы (риск инсульта). <br>
•   **Precision (Точность):** 0.79 - Доля правильно предсказанных случаев инсульта среди всех случаев, которые модель предсказала как инсульт. <br>
•   **Recall (Полнота):** 0.89 - Доля правильно предсказанных случаев инсульта среди всех реальных случаев инсульта. <br>

**Расположение файлов:**

Результаты анализа данных, обученная модель и исходный датасет находятся в папке `iteration1`:

•   `healthcare-dataset-stroke-data.csv` - Исходный датасет, использованный для обучения модели. <br>
•   `model.pkl` - Сериализованный файл с обученной моделью машинного обучения (Gradient Boosting). <br>
•   `ML.ipynb` - Jupyter Notebook, содержащий аналитическую работу, разведочный анализ данных, процесс выбора и обучения  модели, а также оценку ее производительности. 


## Реализация сбора данных в Telegram боте

Этот раздел описывает логику сбора данных от пользователя через Telegram-бота.  Бот использует библиотеку `pyTelegramBotAPI` (Telebot) для взаимодействия с Telegram API.

**Логика работы:**

1.  **Команда `/start`:**
    •   При получении команды `/start` бот инициализирует хранилище данных для нового пользователя (`user_data`).  Каждому пользователю присваивается уникальный ID (`user_id`), который используется как ключ для хранения его данных в словаре `user_data`. <br>
    •   Затем бот вызывает функцию `ask_gender`, чтобы начать опрос с вопроса о поле пользователя. <br>

2.  **Последовательный опрос:**
    •   Бот задает вопросы пользователю в определенной последовательности, используя inline-клавиатуры (для выбора вариантов ответа) и текстовые поля для ввода данных. <br>
    •   Функции `ask_[parameter]` (например, `ask_gender`, `ask_age`, `ask_hypertension`) отправляют сообщения с вопросами и inline-клавиатурами. <br>
    •   Функции `process_[parameter]` (например, `process_gender`, `process_age_step`, `process_hypertension`) обрабатывают ответы пользователя. <br>

3.  **Обработка ответов (Callback Queries и Text Messages):**
    •   **Inline-клавиатуры:**  Когда пользователь нажимает на кнопку в inline-клавиатуре, Telegram отправляет *callback query* боту.  Функции, помеченные декоратором `@bot.callback_query_handler`, обрабатывают эти callback query.  Данные, связанные с кнопкой (например, значение пола, `gender_1` или `gender_0`), извлекаются из `call.data` и сохраняются в `user_data`. <br>
    •   **Текстовый ввод:** Для вопросов, требующих текстового ответа (например, возраст), бот использует `bot.register_next_step_handler`.  Эта функция указывает, какая функция должна быть вызвана для обработки следующего сообщения от пользователя.  В функции-обработчике (например, `process_age_step`) проверяется корректность введенных данных (в данном случае, возраст должен быть числом в определенном диапазоне) и сохраняется в `user_data`. Если данные некорректны, пользователю предлагается ввести их заново. <br>

4.  **Сохранение данных:**
    •   Все ответы пользователя сохраняются в словаре `user_data` под соответствующим `user_id`.  Структура данных для каждого пользователя выглядит примерно так:  <br>

	user_data = {
      user_id: {
        'gender': 1, # 0 - Женщина, 1 - Мужчина
        'age': 45,
        'hypertension': 0, # 0 - Нет, 1 - Да
        'heart_disease': 0, # 0 - Нет, 1 - Да
        'ever_married': 1, # 0 - Нет, 1 - Да
        'work_type': 3, # 0 - Ребенок, 1 - Госслужащий, 2 - Никогда не работал, 3 - Негосударственная работа, 4 - Самозанятый
        # ... (другие параметры)
      }
    }

### Формирование персонализированных рекомендаций

Этот раздел описывает, как чат-бот вычисляет вероятность инсульта и генерирует персонализированные рекомендации по снижению риска инсульта на основе данных, полученных от пользователя.

**Логика работы:**

1.  **Сбор данных пользователя:** 
Как описано в предыдущем разделе, бот собирает информацию о пользователе, включая пол, возраст, состояние здоровья (гипертония, болезни сердца), образ жизни (тип работы, место проживания) и вредные привычки (статус курения), а также клинические показатели (уровень глюкозы, ИМТ).  Эти данные сохраняются в словаре `user_data`. <br>

2. **Формирование запроса для модели машинного обучения:**
После сбора всех необходимых данных формируется запрос в функции make_prediction(chat_id, user_id)  для модели машинного обучения для прогнозирования риска инсульта. А функция get_risk_category(prediction) уже опредеялет категорию риска пациента и присылает ее.   <br>

2.  **Формирование запроса к LLM модели (ask_gigachat):** 
После сбора всех необходимых данных формируется текстовый запрос (`prompt`) для отправки во внешнюю модель (в данном случае, `ask_gigachat`). Этот запрос включает в себя: <br>
    •   Все собранные параметры пользователя. <br>
    •   Инструкции для модели по предоставлению рекомендаций в структурированном формате (Диета, Физическая активность, и т.д.). <br>
    •   Указание на необходимость учета последних рекомендаций медицинских организаций (AHA/ASA). <br>
    •   Строгое предупреждение о недопустимости предоставления медицинских советов, заменяющих консультацию врача. <br>
    •   Ограничение на длину ответа (до 800 символов). <br>


**Расположение файлов:**

Финальная версия чат-бота находятся в папке `final_project`: <br>

•   `interface_new.py` - Основной файл, в котором реализован интерфейс чат-бота, взаимодействия с ML и язковой моделями, также функция для сохранения параметров пользователя в базу данных.  <br>
•   `llm_part.py` - Файл для подключения к API GigaChat и формирования запроса.  <br>
•   `model.pkl` - Сериализованный файл с обученной моделью машинного обучения (Gradient Boosting). <br>

## Разработка базы данных

Длч сохранения данных пользователя мы использовали **PostgesSQL**, а также **Docker** - контейнеризатор приложения. 

**Описание полей таблицы `predictions`:**

•   `id` (SERIAL PRIMARY KEY): Уникальный идентификатор записи (автоматически увеличивающееся целое число).  Первичный ключ таблицы. <br>
•   `gender` (VARCHAR): Пол пользователя. Возможные значения: "Мужчина", "Женщина". <br>
•   `age` (INT): Возраст пользователя (в годах). <br>
•   `hypertension` (INT): Наличие гипертонии. Значение: 0 - Нет, 1 - Да. <br>
•   `heart_disease` (INT): Наличие заболеваний сердца. Значение: 0 - Нет, 1 - Да. <br>
•   `ever_married` (VARCHAR): Семейное положение (когда-либо состоял в браке). Возможные значения: "Да", "Нет". <br>
•   `work_type` (VARCHAR): Тип работы пользователя. Возможные значения: "Ребенок", "Госслужащий", "Никогда не работал", "Негосударственная работа", "Самозанятый". <br>
•   `residence_type` (VARCHAR): Тип места проживания. Возможные значения: "Город", "Село". <br>
•   `avg_glucose_level` (FLOAT): Средний уровень глюкозы в крови (ммоль/л). <br>
•   `bmi` (FLOAT): Индекс массы тела (ИМТ). <br>
•   `smoking_status` (VARCHAR): Статус курения. Возможные значения: "Никогда не курил", "Курил ранее", "Курит", "Неизвестно". <br>
•   `prediction` (INT): Вероятность инсульта (целое число от 0 до 100), представленная в процентах. <br>

**Расположение файлов:**

•   `table.sql` - Файл для создания таблицы, в которой хранятся все данные пользователя.


## Тестирование и подготовка документации

Мы провели несколько видов тестирования

1. Ручное тестирование (прогнали несколько сценариев для поиска уизвимых и сложных мест): <br>
	•	корректный ввод данных пользователем; <br>
	•	обработку некорректных или пустых данных; <br>
	•	сохранение и извлечение данных из базы; <br>
	•	генерацию прогнозов и рекомендаций. <br>
2.	Юнит-тесты <br>
	•	`test_interface.py`

**Используемые инструменты и подходы:**

•   **`unittest` (Python):** Стандартный фреймворк для юнит-тестирования в Python. <br>
•   **`unittest.mock`:** Библиотека для создания мок-объектов, позволяющих изолировать тестируемый код от внешних зависимостей (например, Telegram API, база данных). <br>
•   **Мокирование (Mocking):** Активное использование мок-объектов для подмены внешних зависимостей.  Это позволяет тестировать логику работы бота без необходимости отправлять реальные запросы в Telegram или взаимодействовать с реальной базой данных. <br>
•   **Патчи (Patching):** Использование `@patch` для временной замены объектов (например, функций, классов) мок-объектами во время выполнения теста. <br>
•   **`setUp` и `tearDown`:**  Методы, которые выполняются перед и после каждого теста, используются для инициализации мок-объектов и очистки ресурсов. <br>

### Тестирование чат-бота `test_interface.py`

**Основные компоненты тестового набора:**

•   **`TestBot` (класс):**  Основной класс, содержащий юнит-тесты для различных функций бота. <br>
•   **`setUp(self)` (метод):**  Выполняется перед каждым тестом.  В этом методе создаются мок-объекты для `interface_new. bot`, `interface_new.cursor` и `interface_new.conn`, а также сбрасывается состояние словаря `interface_new.user_data`. <br>
•   **`tearDown(self)` (метод):**  Выполняется после каждого теста.  В этом методе останавливаются патчи, созданные в `setUp`. <br>
•   **`setup_user_data(self, user_id)` (метод):** Вспомогательная функция, которая помогает инициализировать `user_data` для конкретного пользователя. <br>
•   **Тестовые методы (начинаются с `test_`):**  Каждый тестовый метод проверяет определенную функцию бота. <br>

**Примеры тестовых методов:**

•   **`test_start_command(self, mock_ask_gender)`:**
    •   Тестирует обработку команды `/start`. <br>
    •   Проверяет, что функция `ask_gender` (которая запрашивает пол пользователя) вызывается с правильным `chat_id`.
    •   Проверяет, что для пользователя создается запись в словаре `user_data`. <br>
    •   Использует `@patch('interface_new.ask_gender')` для подмены функции `ask_gender` мок-объектом, чтобы избежать реального вызова этой функции. <br>
    •   Использует `mock_ask_gender.assert_called_once_with(456)` для проверки, что мок-объект `ask_gender` был вызван ровно один раз с правильным аргументом. <br>

•   **`test_process_gender(self, mock_ask_age)`:**
    •   Тестирует обработку выбора пола пользователем. <br> 
    •   Проверяет, что значение пола сохраняется в словаре `user_data`. <br>
    •   Проверяет, что вызывается функция `ask_age` (которая запрашивает возраст пользователя). <br>
    •   Использует `@patch('interface_new.ask_age')` для подмены функции `ask_age`. <br>

•   **`test_process_age_step_valid_age(self, mock_ask_hypertension)`:**
    •   Тестирует обработку введенного возраста (в случае, если введен валидный возраст). <br>
    •   Проверяет, что введенный возраст сохраняется в словаре `user_data`. <br>
    •   Проверяет, что вызывается функция `ask_hypertension` (которая запрашивает наличие гипертонии). <br>
    •   Использует `@patch('interface_new.ask_hypertension')` для подмены функции `ask_hypertension`. <br>

По итогу наш бот успешно прошел 14/14 тестов.

### Тестирование загрузки и работы модели машинного обучения `test_ml.py`

**Используемые инструменты:**

•   `unittest` (Python): Фреймворк для юнит-тестирования. <br>
•   `joblib`: Библиотека для эффективной сериализации и десериализации объектов Python, используется для загрузки сохраненной модели. <br>
•   `numpy`: Библиотека для работы с массивами, используется для создания входных данных для модели. <br>

**Структура тестов:**

•   `TestModelLoading` (класс): Основной класс, содержащий тесты для проверки загрузки и работы модели. <br>
•   `setUp(self)` (метод): Выполняется перед каждым тестом. В этом методе происходит попытка загрузки модели из файла `model.pkl`. Если файл не найден или происходит ошибка при загрузке, тест завершается с ошибкой. <br>
•   `test_model_loading_success(self)` (метод): Проверяет, что модель успешно загружена и переменная `self.model` не равна `None` после загрузки. <br>
•   `test_model_prediction_valid_input(self)` (метод): <br>
    *   Создает пример входных данных в формате массива NumPy. Эти данные имитируют типичные данные о пациенте, которые используются моделью для прогнозирования риска инсульта. <br>
    *   Вызывает метод `predict` модели с этими входными данными. <br>
    *   Проверяет, что предсказание успешно получено и не равно `None`. <br>
    *   Включает обработку исключений, чтобы перехватить любые ошибки, которые могут возникнуть во время предсказания, и завершить тест с ошибкой, если предсказание не удалось. <br>

По итогу наша модель успешно прошла 2/2 тестов. 

### Тестирование взаимодействия с GigaChat API

**Используемые инструменты:**

•   `unittest` (Python): Фреймворк для юнит-тестирования. <br>
•   `unittest.mock`: Библиотека для создания mock-объектов, позволяющих имитировать взаимодействие с GigaChat API без отправки реальных запросов. <br>
•   `gigachat`: Библиотека для взаимодействия с GigaChat API. <br>

**Основные компоненты тестового набора:**

•   `TestGigaChat` (класс): Основной класс, содержащий юнит-тесты для функций взаимодействия с GigaChat. <br>
•   `test_connect_gigachat_success(self)` (метод): <br>
    •   Проверяет, что функция `connect_gigachat` успешно устанавливает соединение с GigaChat и возвращает объект типа `GigaChat`. <br>

•   `test_connect_gigachat_credentials(self, mock_gigachat)` (метод): <br>
    •   Проверяет, что функция `connect_gigachat` передает правильные учетные данные (credentials) при инициализации объекта `GigaChat`. <br>
    •   Использует `@patch('llm_part.GigaChat')` для подмены класса `GigaChat` мок-объектом. <br>
    •   Использует `mock_gigachat.assert_called_once_with(...)` для проверки, что мок-объект `GigaChat` был вызван с правильными аргументами (учетными данными, моделью и настройками SSL). <br>

•   `test_ask_gigachat_success(self, mock_gigachat_class)` (метод): <br>
    •   Тестирует успешную отправку запроса в GigaChat и получение ответа. <br>
    •   Использует `@patch('llm_part.GigaChat')` для подмены класса `GigaChat` мок-объектом. <br>
    •   Имитирует ответ от GigaChat, создавая мок-объект `mock_response` с фиктивными данными. <br>
    •   Проверяет, что функция `ask_gigachat` вызывает метод `chat` мок-объекта `GigaChat` с правильным запросом (prompt) и настройками (temperature, top_p). <br>
    •   Проверяет, что функция `ask_gigachat` возвращает правильный ответ, извлеченный из мок-объекта `mock_response`. <br>
    •   Особое внимание уделяется проверке структуры запроса, отправляемого в GigaChat (наличие поля `messages` с правильным содержимым). <br>
 
По итогу не было найдено ошибок во взаимодействие с LLM, успешно пройдены 3/3 тестов.

### Зоны ответствености каждого участика проекта

1.	Backend-инженер (тимлид): <br>
	-	отвечает за проектирование архитектуры приложения; <br>
	-	разрабатывает основные компоненты системы; <br>
	-	создает и управляет базой данных; <br>
	-   настраивает взаимодействие модели с backend и базой данных. <br>
	-	отвечает за организацию команды. <br>

2.	Backend-инженер (интерфейсы и LLM): <br>
	-	участвует в проектировании системы; <br>
	-	проводит тестирование всех частей проекта; <br>
	-	настраивает подключение приложения с LLM, создает promt <br>
	-   настраивает взаимодействие backend с базой данных. <br>
	-	пишет документацию. <br>

3.	ML-инженер: <br>
	-   проводит анализ датасета; <br>
	-	ищет и подготавливает данные для обучения модели; <br>
	-	обучает и оптимизирует модель; <br>
	-	настраивает взаимодействие модели с backend и базой данных. <br>

